# Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/reference/configuration-reference
version: 2.1

# Define parameters for the workflow
parameters:
  github_username:
    type: string
    default: "bak3y"
  image_name:
    type: string
    default: "k8s-ephemeral-storage-metrics"
  dockerfile:
    type: string
    default: "Dockerfile"

# Define reusable commands
commands:
  setup-docker-buildx:
    description: "Setup Docker Buildx for multi-platform builds"
    steps:
      - run:
          name: Setup Docker Buildx
          command: |
            docker buildx version
            docker buildx create --name builder --use || true
            docker buildx inspect --bootstrap

  determine-image-tag:
    description: "Determine the image tag using commit SHA"
    steps:
      - run:
          name: Determine image tag
          command: |
            IMAGE_TAG="${CIRCLE_SHA1:0:7}"
            echo "export IMAGE_TAG=$IMAGE_TAG" >> $BASH_ENV
            echo "export FULL_IMAGE_NAME=ghcr.io/${GITHUB_USERNAME}/${IMAGE_NAME}:${IMAGE_TAG}" >> $BASH_ENV
            echo "export LATEST_IMAGE_NAME=ghcr.io/${GITHUB_USERNAME}/${IMAGE_NAME}:latest" >> $BASH_ENV
            # Persist for other jobs
            echo "$IMAGE_TAG" > /tmp/image_tag.txt
            echo "${FULL_IMAGE_NAME}" > /tmp/full_image_name.txt
            echo "${LATEST_IMAGE_NAME}" > /tmp/latest_image_name.txt

# Define a job to be invoked later in a workflow.
# See: https://circleci.com/docs/guides/orchestrate/jobs-steps/#jobs-overview & https://circleci.com/docs/reference/configuration-reference/#jobs
jobs:
  build:
    machine:
      image: ubuntu-2204:current
    environment:
      IMAGE_NAME: << pipeline.parameters.image_name >>
      DOCKERFILE: << pipeline.parameters.dockerfile >>
      GITHUB_USERNAME: << pipeline.parameters.github_username >>
    steps:
      - checkout
      - setup-docker-buildx
      - determine-image-tag
      - run:
          name: Build Docker image (single platform for scanning)
          command: |
            docker buildx build \
              --platform linux/amd64 \
              --tag "${FULL_IMAGE_NAME}" \
              --file "${DOCKERFILE}" \
              --load \
              .
      - run:
          name: Save image to tar for scanning
          command: |
            docker save "${FULL_IMAGE_NAME}" -o /tmp/image.tar
      - persist_to_workspace:
          root: /tmp
          paths:
            - image_tag.txt
            - full_image_name.txt
            - latest_image_name.txt
            - image.tar

  scan:
    machine:
      image: ubuntu-2204:current
    environment:
      IMAGE_NAME: << pipeline.parameters.image_name >>
      GITHUB_USERNAME: << pipeline.parameters.github_username >>
    steps:
      - attach_workspace:
          at: /tmp
      - run:
          name: Load image metadata
          command: |
            export IMAGE_TAG=$(cat /tmp/image_tag.txt)
            export FULL_IMAGE_NAME=$(cat /tmp/full_image_name.txt)
            export LATEST_IMAGE_NAME=$(cat /tmp/latest_image_name.txt)
            echo "export IMAGE_TAG=$IMAGE_TAG" >> $BASH_ENV
            echo "export FULL_IMAGE_NAME=$FULL_IMAGE_NAME" >> $BASH_ENV
            echo "export LATEST_IMAGE_NAME=$LATEST_IMAGE_NAME" >> $BASH_ENV
      - run:
          name: Scan image for vulnerabilities
          command: |
            # Scan the image tar file before pushing using Trivy's official container
            # Exit code 0 allows the build to continue even if vulnerabilities are found
            # Change --exit-code 1 to fail the build on HIGH/CRITICAL vulnerabilities
            docker run --rm \
              -v /tmp:/tmp \
              aquasec/trivy:latest image \
              --input /tmp/image.tar \
              --exit-code 0 \
              --severity HIGH,CRITICAL \
              --format table

  push:
    machine:
      image: ubuntu-2204:current
    environment:
      IMAGE_NAME: << pipeline.parameters.image_name >>
      DOCKERFILE: << pipeline.parameters.dockerfile >>
      GITHUB_USERNAME: << pipeline.parameters.github_username >>
    steps:
      - checkout
      - attach_workspace:
          at: /tmp
      - setup-docker-buildx
      - run:
          name: Load image metadata
          command: |
            if [ ! -f /tmp/image_tag.txt ] || [ ! -f /tmp/full_image_name.txt ] || [ ! -f /tmp/latest_image_name.txt ]; then
              echo "Error: Image metadata files not found in workspace"
              exit 1
            fi
            export IMAGE_TAG=$(cat /tmp/image_tag.txt)
            export FULL_IMAGE_NAME=$(cat /tmp/full_image_name.txt)
            export LATEST_IMAGE_NAME=$(cat /tmp/latest_image_name.txt)
            if [ -z "$FULL_IMAGE_NAME" ]; then
              echo "Error: FULL_IMAGE_NAME is empty"
              exit 1
            fi
            echo "export IMAGE_TAG=$IMAGE_TAG" >> $BASH_ENV
            echo "export FULL_IMAGE_NAME=$FULL_IMAGE_NAME" >> $BASH_ENV
            echo "export LATEST_IMAGE_NAME=$LATEST_IMAGE_NAME" >> $BASH_ENV
            echo "Loaded image metadata: $FULL_IMAGE_NAME"
      - run:
          name: Login to GitHub Container Registry
          command: |
            if [ -z "$GITHUB_TOKEN" ]; then
              echo "Error: GITHUB_TOKEN environment variable is not set"
              exit 1
            fi
            # Create Docker config with GHCR authentication
            mkdir -p ~/.docker
            echo -n "${GITHUB_USERNAME}:${GITHUB_TOKEN}" | base64 > /tmp/auth.txt
            echo "{\"auths\":{\"ghcr.io\":{\"auth\":\"$(cat /tmp/auth.txt)\"}}}" > ~/.docker/config.json
            rm /tmp/auth.txt
      - run:
          name: Build and push Docker image (multi-platform)
          command: |
            docker buildx build \
              --platform linux/amd64,linux/arm64 \
              --tag "${FULL_IMAGE_NAME}" \
              --file "${DOCKERFILE}" \
              --push \
              .
      - run:
          name: Tag as latest (if on main/master branch)
          command: |
            if [ "$CIRCLE_BRANCH" = "master" ] || [ "$CIRCLE_BRANCH" = "main" ]; then
              docker buildx imagetools create "${FULL_IMAGE_NAME}" --tag "${LATEST_IMAGE_NAME}"
            fi
      - run:
          name: Output image information
          command: |
            echo "Successfully built and pushed:"
            echo "  - ${FULL_IMAGE_NAME}"
            if [ "$CIRCLE_BRANCH" = "master" ] || [ "$CIRCLE_BRANCH" = "main" ]; then
              echo "  - ${LATEST_IMAGE_NAME}"
            fi

# Orchestrate jobs using workflows
# See: https://circleci.com/docs/guides/orchestrate/workflows/ & https://circleci.com/docs/reference/configuration-reference/#workflows
workflows:
  build-scan-push:
    # Run on all pushes and tags
    # To limit to specific branches, add filters to the jobs below
    jobs:
      - build
      - scan:
          requires:
            - build
      - push:
          requires:
            - scan
